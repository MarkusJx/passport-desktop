/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/** A key creation option. */
export const enum KeyCreationOption {
  /** Replace an existing key. */
  ReplaceExisting = 0,
  /** Throw an error if the key already exists. */
  FailIfExists = 1
}
/** The public key encoding to use. */
export const enum PublicKeyEncoding {
  X509SubjectPublicKeyInfo = 0,
  /**
   * The key is a PKCS#1 RSA DER-encoded public key.
   * This is the default encoding as it is the
   * most useful for interoperability.
   */
  Pkcs1RsaPublicKey = 1,
  BCryptPublicKey = 2,
  Capi1PublicKey = 3,
  BCryptEccFullPublicKey = 4
}
/** The result of a user consent verification operation. */
export const enum VerificationResult {
  /** The user consent verification operation succeeded. */
  Verified = 0,
  /**
   * The user consent verification operation failed
   * because the device is not present.
   */
  DeviceNotPresent = 1,
  /**
   * The user consent verification operation failed
   * because Windows Hello is not configured for the user.
   */
  NotConfiguredForUser = 2,
  /**
   * The user consent verification operation failed
   * because Windows Hello is disabled by policy.
   */
  DisabledByPolicy = 3,
  /**
   * The user consent verification operation
   * failed because the device is busy.
   */
  DeviceBusy = 4,
  /**
   * The user consent verification operation failed
   * because the maximum number of attempts was exceeded.
   */
  RetriesExhausted = 5,
  /**
   * The user consent verification operation
   * was canceled by the user.
   */
  Canceled = 6
}
/**
 * The Passport module provides an interface to the Windows Hello API.
 * It allows you to create a key pair and sign data using the private key.
 * The public key can be exported in a variety of formats.
 *
 * # Example
 * ```ts
 * import { Passport, PublicKeyEncoding, KeyCreationOption } from 'node-ms-passport';
 * import { randomBytes } from 'crypto';
 *
 * if (!Passport.available()) {
 *   throw new Error('Windows Hello is not available');
 * }
 *
 * await Passport.accountWithIdExists('my-account-id'); // false
 *
 * const passport = new Passport('my-account-id');
 * if (!passport.accountExists) {
 *   await passport.createAccount(KeyCreationOption.FailIfExists);
 * }
 *
 * const challenge = randomBytes(32);
 * const signature = await passport.sign(challenge);
 *
 * // Verify the signature with the public key
 * const keyBuffer = await passport.getPublicKey(PublicKeyEncoding.Pkcs1RsaPublicKey);
 * const key = createPublicKey({
 *   key: keyBuffer,
 *   format: 'der',
 *   type: 'pkcs1'
 * });
 *
 * // Create a verifier and verify the challenge
 * const verify = createVerify('SHA256');
 * verify.write(challenge);
 * verify.end();
 *
 * verify.verify(key, signature); // true
 *
 * // Delete the account
 * await passport.deleteAccount();
 * ```
 */
export class Passport {
  /**
   * Create a new Passport instance.
   * The account_id is used to identify the account in the Windows Credential Manager.
   * If an account with the given id already exists, it will be used.
   * You can check if an account exists with the `accountExists` getter.
   *
   * # Example
   * ```ts
   * import { Passport } from 'node-ms-passport';
   *
   * const passport = new Passport('my-account-id');
   * ```
   *
   * @param accountId The id of the account in the Windows Credential Manager.
   */
  constructor(accountId: string)
  /**
   * Create a new passport account.
   * You can optionally pass a {@link KeyCreationOption} to customize the key creation.
   * If no option is passed, an existing key will be replaced.
   * If the account does not exist, it will be created.
   *
   * # Example
   * ```ts
   * import { Passport, KeyCreationOption } from 'node-ms-passport';
   *
   * const passport = new Passport('my-account-id');
   * await passport.createAccount(KeyCreationOption.FailIfExists);
   * ```
   *
   * @param creationOption The {@link KeyCreationOption} to use when creating the key.
   */
  createAccount(creationOption?: KeyCreationOption | undefined | null): Promise<void>
  /**
   * Sign a challenge with the private key.
   * If the account does not exist, an error will be thrown.
   * This will open a Windows Hello dialog to verify the user.
   * If the challenge is not verified, an error will be thrown.
   *
   * The signature can be verified with the public key, for example
   * using the `crypto` module.
   *
   * # Example
   * ```ts
   * import { Passport, PublicKeyEncoding } from 'node-ms-passport';
   * import { randomBytes, createPublicKey, createVerify } from 'crypto';
   *
   * const passport = new Passport('my-account-id');
   * // Create the key pair
   * await passport.createAccount();
   *
   * // Create a challenge and sign it
   * const challenge = randomBytes(32);
   * const signature = await passport.sign(challenge);
   *
   * // Verify the signature with the public key
   * const keyBuffer = await passport.getPublicKey(PublicKeyEncoding.Pkcs1RsaPublicKey);
   * const key = createPublicKey({
   *   key: keyBuffer,
   *   format: 'der',
   *   type: 'pkcs1'
   * });
   *
   * // Create a verifier and verify the challenge
   * const verify = createVerify('SHA256');
   * verify.write(challenge);
   * verify.end();
   *
   * verify.verify(key, signature); // true
   * ```
   *
   * @see {@link getPublicKey}
   * @param challenge The challenge to sign.
   * @return The signature.
   */
  sign(challenge: Buffer): Promise<Buffer>
  /**
   * Delete the account from the Windows Credential Manager.
   * If the account does not exist, an error will be thrown.
   */
  deleteAccount(): Promise<void>
  /**
   * Get the public key of the account.
   * If the account does not exist, an error will be thrown.
   * The encoding of the key can be specified, defaulting to
   * {@link PublicKeyEncoding.Pkcs1RsaPublicKey}.
   *
   * In order to verify a signature using this public key,
   * use the {@link PublicKeyEncoding.Pkcs1RsaPublicKey}
   * encoding and pass the result to the `crypto` module.
   *
   * # Example
   * ```ts
   * import { Passport, PublicKeyEncoding } from 'node-ms-passport';
   * import { createPublicKey } from 'crypto';
   *
   * const passport = new Passport('my-account-id');
   * // Create the key pair
   * await passport.createAccount();
   *
   * const keyBuffer = await passport.getPublicKey(PublicKeyEncoding.Pkcs1RsaPublicKey);
   * // Use these options to load the public key
   * const key = createPublicKey({
   *   key: keyBuffer,
   *   format: 'der',
   *   type: 'pkcs1'
   * });
   * ```
   *
   * @see {@link sign}
   * @param encoding The encoding to use for the public key.
   * @return The public key.
   */
  getPublicKey(encoding?: PublicKeyEncoding | undefined | null): Promise<Buffer>
  /**
   * Whether the account exists in the Windows Credential Manager.
   * This is only updated if the account exists when the Passport
   * instance is created and when {@link createAccount} or
   * {@link deleteAccount} are called. If the account is deleted
   * or created outside of this instance, this value will not be
   * updated.
   */
  get accountExists(): boolean
  /**
   * Whether the Passport API is available on the current platform
   * and the current user has permission to use it.
   *
   * @return Whether the Passport API is available.
   */
  static available(): boolean
  /**
   * Whether an account with the given ID exists in the Windows
   * Credential Manager.
   *
   * @param id The ID of the account to check.
   * @return Whether the account exists.
   */
  static accountWithIdExists(id: string): boolean
  /**
   * Request verification from the user. This will show a dialog
   * to the user asking them to verify their identity. If the user
   * accepts, the returned value will be {@link VerificationResult.Verified}.
   * If the user rejects or cancels the dialog, the returned value will be
   * another value from {@link VerificationResult} specifying the rejection
   * reason.
   *
   * # Example
   * ```ts
   * import { Passport, VerificationResult } from 'node-ms-passport';
   *
   * const result = await Passport.requestVerification('Please verify your identity');
   * if (result === VerificationResult.Verified) {
   *   console.log('User verified');
   * } else {
   *   console.log('User rejected verification');
   * }
   * ```
   *
   * @param message The message to show to the user.
   * @return The result of the verification request.
   */
  static requestVerification(message: string): Promise<VerificationResult>
}
